#### 一、作用域（scope）

​	变量与函数的可访问范围，控制着变量与函数的可见性与生命周期

###### 		1、全局作用域

​		直接写在script下面的代码（或者单独的js文件）

​		可见性：在代码的任何地方都可以访问

​		生命周期：伴随着页面的生命周期（关闭页面时结束）

​		其他情况：函数内部不使用任何关键子声明的变量，**会成为全局变量**

###### 		2、局部作用域

​		ES5之前，函数内部声明的变量，只能在函数内部访问，外部无法访问

​		可见性：函数外部无法访问

​		**生命周期：变量再函数调用完后就销毁**

```js
function fn() {
            const a = 1
            let b = 2
            var c = 3
        }
        fn()
        console.log(a,b,c)//不能访问,a,b,c是函数内部声明的局部变量
```

​		其他：

​			①使用let const 声明的变量，再{}中会产生块级作用域

​			② 块级作用域外部不能访问内部变量

​			③两个块级作用域中的变量互不影响

<hr>

#### 二、作用域链

​	优先再当前作用域中查找变量；如果再当前作用域中找不到这个变量，则依次逐级查找父级作用域，直到全局作用域

<hr>

#### 三、垃圾回收

​	内存不使用的时候，会被垃圾回收程序自动回收（js中内存的分配和资源的回收都是自动完成的）

<hr>

#### 四、内存泄漏

###### 	1、什么是内存泄漏?

​		不再用到的内存，没有及时释放，就叫做内存泄漏

###### 	2.内存的生命周期是什么样的?

​		内存分配、内存使用、内存回收
​		全局变量-般不会回收; -般情况下局部变量的值,不用了，会被自动
​		回收掉

<hr>

#### 五、释放内存

###### 		1、引用计数法

​		在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加一；当引用失效时，计数器的值就减一。当某一时刻计数器的值为零时，这个对象就不再被使用。

​		引用计数法的优势是**简单、效率高**。缺点也很明显**单纯的引用计数很难解决对象之间的循环引用问题**

**算法:**
	①跟踪记录每个值被引用的次数。
	②如果这个值的被引用了一 次，那么就记录次数1

​	③多次引用会累加。

​	④.如果减少一个引用就减1。
​	⑤如果引用次数是0，则释放内存。

###### 	2、标记清除法

​		第一步：标记。标记出需要回收的对象。

​		第二步：清除。清除被标记的对象。（也可以反过来，标记存活的对象，清除没有被标记的对象）

<hr>

#### 六、闭包

###### 	1、内部函数引用外部函数变量的集合

​		闭包 = 内层函数+外层函数变量
​		产生条件：①有内层函数②内层函数使用了外层函数的变量。**内层函数一般作为返回值返回**

###### 	2、闭包的作用

​		外部可以访问函数内部的变量但是不能修改这个变量

###### 	3、闭包的应用

​		实现数据的私有化

​		可以做一些性能优化：

```js
// 防抖和节流 
// 防抖 debounce
// 节流 throttle 
```

###### 	3、闭包的生命周期：

​		内部函数被创建时就产生闭包，但外部函数调用时才能执行函数定义，所以在外部函数被调用时产生，外部函数每次调用都会产生一个全新的闭包
毁（内部函数被垃圾回收了，闭包才会消失）

###### 	4、相比于类（私有化属性方面）

```js
相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能），
需要执行次数较少时，使用闭包
需要大量创建实例时，使用类
```

###### 	5、闭包的缺陷

​		存在内存泄漏问题，关掉浏览器之后 内存才会被回收。

<hr>

#### 六、函数参数

###### 		1、动态参数:arguments

​		内置对象，伪数组，接收实参

###### 		2、rest剩余参数

​	（也就是参数是。。。arr的情况下）：是真数组	,有其他参数也有rest剩余参数的时候，剩余参数必须写在最后面

<hr>

#### 七、展开运算符	

​	1、展开运算符也就是。。。arr ,相当于是rest剩余参数的逆运算

```js
const arr = [1,2,3,4,5]
        console.log(Math.max(...arr))
        const arr1 = [7,8,9]
        console.log(arr3 = [...arr ,...arr1])
```

​    2、展开运算符也可以将伪数组转化为真数组

```js
 const divs = document.querySelectorAll('div')
        console.log([...divs])
```

​	3、Array.from(伪数组) 也可以将伪数组转化为真数组

```js
 const arr = Array.from(divs)
        console.log(arr)
```

<hr>

#### 八、this指向

​	this是一个变量，它的值是存的是一个对象

​	粗略的规则：谁调用 this就指向谁

###### 		1、在全局坏境中，this 指向的是widow，

###### 	2、构造函数的this 指向实例对象

###### 	3、call() 、apply() 、bind() 的this指向指定的	

```js
 fn.call(window)//指定this指向
    fn.apply(obj) //指定this指向   
    fn.apply() //this指向函数本身  
    fn.call() //this指向函数本身
// 2.两者区别
    //   传参方式不同
    fn.call(obj,实参)  //第一个参数指定this指向，第二个参数指定实参的值
    fn.apply(obj,[实参])   
```

```js
// 1.bind()用来创建一个新的函数,第一个参数是绑定死this，后面的参数是绑定死实参，只对于生成的新函数
// 2.
        const obj = {
            name:1
        }
        
        function fn(a,b){
            console.log('fn执行',this,a,b)
        }
        const newfn = fn.bind(obj,10) //绑定死newfn的this 和newfn()第一个参数为10
        newfn(1,2)// 10 1
```



###### 		4、函数内部，this指向取决于这个函数被调用的方式，

​		**①普通函数的调用**

​			this指向的是widow

```js
function fn（）{
	console.log(this)								
}
fn()//这里的fn()相当于widow.fn()
//所以这里this指向的是widow
```

​		**②函数作为对象的方法调用**

​			this指向这个对象	

```js
let obj = {
            name:'张三',
            fn1:function(){
                console.log(this)
            }
        }
        obj.fn1()//this 指向obj
        
```

​		**③事件绑定中，this指向注册（绑定）事件的元素**	

```js
// 事件绑定中，this指向注册（绑定）事件的元素
        const btn  = document.querySelector('button')
        btn.addEventListener('click',function(){
            console.log(this)//this 指向的button
            this.innerHTML = '张三'
        })
```

<hr>

#### 九、检测数组的方式

​	1、arr instansof   Array，返回true或false

​	2、Objeect.prototype.toString.call(arr)，返回的是Arrary

​	3、Array.isArray（arr）：返回true或false

```js
const arr = [1,2]
        console.log(arr instanceof Array)
        console.log( Object.prototype.toString.call(arr))
        console.log(Array.isArray(arr))
```

<hr>

#### 十、解构赋值(模式匹配)

​	ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

###### 	1、数组解构

​		[a,b,c] = [1,2,3] 得到a =1,b=2,c=3

​		①数组的解构可以用于交换变量

```js
;[a,b] = [b ,a]//中括号前面加括号
```

​		②解构赋值可以给左边的变量设置初始值

​		③当右边对应的位置不存在元素，或者严格等于undefined使用默认值

```js
const [a = 1, b = 1] = ['undefined', undefined]
        console.log(a, b)// undefined 1
		//当右边对应的位置不存在元素，或者严格等于undefined使用默认值
```

​		④当右边不是数组时，就会报错

###### 	2、对象解构

```js
const {name, age}  = {name:'练练', age:18}//可以交换顺序，因为对象是无序的
//改变属性名字：
const { name: user, age } = obj
        console.log(user, age)
```

<hr>

























